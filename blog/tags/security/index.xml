<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Security on perl11 blog</title>
    <link>http://perl11.org/blog/tags/security.xml</link>
    <description>Recent content in Security on perl11 blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2016 Copyright Reini Urban</copyright>
    <atom:link href="http://perl11.org/blog/tags/security.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>safeclib-3.3 and its new compile-time checks</title>
      <link>http://perl11.org/blog/safeclib-3.3.html</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/safeclib-3.3.html</guid>
      <description>

&lt;p&gt;In the previous
&lt;a href=&#34;foldcase.html&#34;&gt;&amp;ldquo;The sad state of foldcase and string comparisons&amp;rdquo;&lt;/a&gt;
article I already mentioned my safeclib library improvements, for the
surpringly rather unique ability to search for strings (with Unicode
support).&lt;/p&gt;

&lt;p&gt;With the recent
&lt;a href=&#34;https://github.com/rurban/safeclib/releases/tag/v03032018&#34;&gt;safeclib-3.3&lt;/a&gt;
release I made the almost same improvements as in cperl: Adding lots
of compile-time checks and seperating them out of the run-time. Do less
branching at run-time when the compiler can already prove that a
certain branch or check was already done at compile-time. With cperl
it is much easier, because there I can control both, the compiler and
the run-time. All in one exectable.&lt;/p&gt;

&lt;p&gt;With safeclib, the user just includes safeclib via
&lt;code&gt;#include &amp;quot;safe_lib.h&amp;quot;&lt;/code&gt; and compiles and links it with his own compiler.
There&amp;rsquo;s it&amp;rsquo;s much harder. Both clang and gcc do support such compile-time
checks via &lt;code&gt;__builtin_object_size&lt;/code&gt; (aka &lt;strong&gt;BOS&lt;/strong&gt;) and the ill-designed
&lt;code&gt;__builtin_choose_expr&lt;/code&gt;, and clang-5+ can now even throw user-defined
compile-time errors via &lt;code&gt;__attribute__((diagnose_if))&lt;/code&gt;, which is
extremely powerful and heavily used with safeclib-3.3.  All checks
which were previously done at run-time, to check for NULL pointers,
empty sizes, wrong size arguments for pointer sizes, overflows,
pointer overlaps and wrong constant values are now done at
compile-time with clang-5+. With a proper development environment,
e.g. emacs with flycheck or flymake with a check-syntax target in your
Makefile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# emacs flymake-mode
check-syntax:
    test -n &amp;quot;$(CHK_SOURCES)&amp;quot; &amp;amp;&amp;amp; \
      $(COMPILE) -o /dev/null -S $(CHK_SOURCES)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every wrong argument to a safeclib function is already warned about in
your IDE. &lt;img src=&#34;images/flymake-safec.png&#34;&gt;
On every keypress flymake runs the compiler on your C source via the
&lt;code&gt;make check-syntax CHK_SOURCES=&amp;quot;your-c-source.c&amp;quot;&lt;/code&gt; makefile target, and then
displays warnings in blue and errors in red, with the message as mouse-over
hover.&lt;/p&gt;

&lt;p&gt;strcat_s is defined in &lt;code&gt;safe_str_lib.h&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXTERN errno_t
_strcat_s_chk(char * restrict dest, rsize_t dmax, const char * restrict src,
              const size_t destbos)
    BOS_CHK(dest) BOS_NULL(src);
#define strcat_s(dest,dmax,src) _strcat_s_chk(dest,dmax,src,BOS(dest))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the new compile-time checks &lt;code&gt;BOS_CHK(dest)&lt;/code&gt; and &lt;code&gt;BOS_NULL(src)&lt;/code&gt; are defined in &lt;code&gt;safe_compile.h&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define BOS_CHK(dest)                                                 \
  __attribute__((diagnose_if(_BOS_OVR(dest,dmax), &amp;quot;dest overflow&amp;quot;, &amp;quot;error&amp;quot;))) \
  __attribute__((diagnose_if(_BOS_NULL(dest), &amp;quot;empty dest&amp;quot;, &amp;quot;error&amp;quot;))) \
  __attribute__((diagnose_if(_BOS_ZERO(dest,dmax), &amp;quot;empty dest or dmax&amp;quot;, &amp;quot;error&amp;quot;)))

#define BOS_NULL(dest)                                                  \
  __attribute__((diagnose_if(_BOS_NULL(dest), &amp;quot;empty dest&amp;quot;, &amp;quot;error&amp;quot;)))

#define _BOS_OVR(dest,dmax)    (_BOS_KNOWN(dest) &amp;amp;&amp;amp; (size_t)(dmax) &amp;gt; BOS(dest))
#define _BOS_ZERO(dest,dmax)   ((_BOS_KNOWN(dest) &amp;amp;&amp;amp; BOS(dest) == 0) || (dmax) == 0)
#define _BOS_NULL(dest)        ((_BOS_KNOWN(dest) &amp;amp;&amp;amp; BOS(dest) == 0) || !(dest))

#define BOS(dest)  __builtin_object_size((dest),1)
#define _BOS_KNOWN(dest)  ((size_t)BOS(dest) != BOS_UNKNOWN)
#define BOS_UNKNOWN ((size_t)-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So whenever a string, dest, is known to have a constant size, and the
size dmax is known to be constant at constant-folding time in the
compiler, BOS will not return BOS_UNKNOWN and the check expression
will be reduced to a constant integer, and a warning or error can be thrown.&lt;/p&gt;

&lt;h1 id=&#34;todo-static-assert-constexpr&#34;&gt;TODO static_assert/constexpr&lt;/h1&gt;

&lt;p&gt;With other compilers it&amp;rsquo;s not that easy. Almost all other compilers do
have BOS support for such constant-folding checks. But gcc will throw
an error if any argument to a compile-time expression is unknown/not a
constant, &lt;code&gt;constant_p&lt;/code&gt; does not help for non-pointers and BOS is not
known for &lt;code&gt;choose_expr&lt;/code&gt; so it cannot be used.  Also
&lt;code&gt;static_assert&lt;/code&gt; is only a statement and not an expression. &lt;code&gt;constexpr&lt;/code&gt; is
only available to g++, not gcc.&lt;/p&gt;

&lt;p&gt;You can write your own &lt;code&gt;static_assert&lt;/code&gt; as expression, the linux kernel
has such tricks.&lt;/p&gt;

&lt;p&gt;E.g. you can define &lt;code&gt;memcpy_s&lt;/code&gt; as such for gcc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* gcc bug: BOS is not a valid constant compile-time expression for gcc-7 */
#define memcpy_s(dest,dmax,src,slen)               \
    IFCONSTP(dmax, dmax != 0,                       \
      IFCONSTP(dmax, dmax &amp;lt; RSIZE_MAX_STR,          \
        IFCONSTP(dest, dest != NULL,                \
          IFCONSTP(src, src != NULL,                \
            _memcpy_s_chk(dest,dmax,src,slen,BOS(dest),BOS(src)), \
            &amp;quot;src is null&amp;quot;),                         \
          &amp;quot;dest is null&amp;quot;),                          \
        &amp;quot;dmax &amp;gt; max&amp;quot;),                              \
      &amp;quot;dmax is zero&amp;quot;)

#define CONSTP(ptr) __builtin_constant_p(ptr)
#define CHOOSE_EXPR(exp,ok,notok)    __builtin_choose_expr(exp,ok,notok)
#define IFCONSTP(var,exp,ok,errmsg) \
  CHOOSE_EXPR(CONSTP(var) ? (exp) : 1, (ok), &amp;quot;&amp;quot;errmsg[-1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;&amp;quot;errmsg[-1]&lt;/code&gt; will expand to &lt;code&gt;&amp;quot;src is null&amp;quot;[-1]&lt;/code&gt; which be an illegal
array access, and a compiler error error will be thrown with a useful
error message. This &lt;code&gt;memcpy_s()&lt;/code&gt; can be used within expressions, within
comma-lists unlike &lt;code&gt;static_assert&lt;/code&gt;.  But the problem is that some
expressions in this nested check, like &lt;code&gt;dmax &amp;gt; BOS(dest)&lt;/code&gt; (&amp;ldquo;dest
overflow&amp;rdquo;) will be invalid if the BOS is unknown.  The BOS for dest is
only known for stack allocation and direct malloc using system malloc
with &lt;code&gt;alloc_size&lt;/code&gt; support, and if the variable is not passed into longer
functions with insufficient compiler optimization levels, without
proper var-tracking. So that the compiler cannot prove the size of a
certain symbol, only its type.&lt;/p&gt;

&lt;p&gt;So only some errors can be detected with gcc at compile-time, not all
run-time checks can be performed at compile-time, and as such the
run-time has to suffer from a ~10% performance degradation.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also Intel&amp;rsquo;s MPX &lt;strong&gt;Pointer Bounds Checker&lt;/strong&gt; using special
registers and a hardware hash table for each pointer to hold the size
of an array, to be able to do fast run-time bounds checks. &lt;code&gt;icc&lt;/code&gt; has
this since icc-15, gcc since 5. In gcc performant only since 5.3. But
it is optional, not shipped with your packagers gcc. safeclib does
throw such mpx violations if supported, but in practice it&amp;rsquo;s very
rarely supported. BOS checks are much more common and successful,
esp. with clang-5+.&lt;/p&gt;

&lt;p&gt;The linux kernel compiletime assertions do look this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_STATIC_ASSERT
# define __compiletime_assert(condition,msg,prefix,suffix) \
    static_assert(condition,msg);
#else
/* linux kernel a-like compile checks */
# if __has_attribute(error)
#  define __compiletime_error(msg) __attribute__((error(msg)))
#  define __compiletime_error_fallback(cond,msg) do { } while (0)
# else
#  define __compiletime_error(msg)
#  define __compiletime_error_fallback(cond,msg)                         \
         do { ((void)sizeof(char[1 - 2 * cond])); } while (0)
# endif
# define __compiletime_assert(condition, msg, prefix, suffix)           \
    do {                                                                \
        bool __cond = !(condition);                                     \
        extern void prefix ## suffix(void) __compiletime_error(msg);    \
        if (__cond) {                                                   \
            prefix ## suffix();                                         \
        }                                                               \
        __compiletime_error_fallback(__cond, msg);                      \
    } while (0)
#endif
#define _compiletime_assert(condition, msg, prefix, suffix)             \
        __compiletime_assert(condition, msg, prefix, suffix)
#define compiletime_assert(condition, msg)                              \
        _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and its usage would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define CT_DEST_NULL(ptr) \
    ({compiletime_assert(ptr != NULL, #ptr &amp;quot; is null&amp;quot;)},ptr)
#define CT_DMAX_ZERO(var)\
    ({compiletime_assert(var != 0, #var &amp;quot; is zero&amp;quot;)},var)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of &lt;code&gt;__LINE__&lt;/code&gt; as unique suffix, &lt;code&gt;__COUNTER__&lt;/code&gt; would be better,
esp. inside expressions, which can have multiple such asserts in a
single line. e.g. a function call. The unique suffix is needed for the
empty function with an &lt;code&gt;__attribute((error))&lt;/code&gt; attribute to throw the
user-defined error, similar to clang&amp;rsquo;s diagnose_if.
The &lt;code&gt;(void)sizeof(char[1 - 2 * cond]&lt;/code&gt; bit throws the compile-time error
if &lt;code&gt;cond&lt;/code&gt; is false and returns the value if &lt;code&gt;cond&lt;/code&gt; is true.&lt;/p&gt;

&lt;p&gt;The kernel has dirty thinks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define CT_DEST_NULL(ptr) ((void *)sizeof(struct { int:-!!(ptr); }))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with &lt;code&gt;!!(ptr)&lt;/code&gt; collapsing the pointer value to a boolean to 0 or 1,
with -1 being the invalid bitfield size, leading to the compile-time
error. But this is hardly portable, and anon structs are not valid with
&lt;code&gt;-pedantic&lt;/code&gt;, which is used for safeclib.&lt;/p&gt;

&lt;p&gt;So why not using static_assert statement checks?&lt;/p&gt;

&lt;p&gt;This depends on the compiler ability to track the size of variables
across function boundaries. We can only add the &lt;code&gt;static_assert&lt;/code&gt; at the beginning
of the body of our functions, e.g. &lt;code&gt;strcat_s&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXPORT errno_t
_strcat_s_chk (char *restrict dest, rsize_t dmax, const char *restrict src,
               size_t destbos)
{
    static_assert(dmax &amp;lt;= destbos, &amp;quot;dest overflow&amp;quot;);
    static_assert(dmax != 0, &amp;quot;dmax is zero&amp;quot;);
    static_assert(dest != NULL, &amp;quot;dest is null&amp;quot;);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with &lt;code&gt;#define strcat_s(dest,dmax,src) _strcat_s_chk(dest,dmax,src,BOS(dest))&lt;/code&gt;
Very few optimizers will be able to deduce dmax to be a compile-time constant into
&lt;code&gt;_strcat_s_chk&lt;/code&gt;, even if we calculate BOS before calling the function and pass it into it.&lt;/p&gt;

&lt;p&gt;So &lt;strong&gt;gcc sucks big time when compared to clang&lt;/strong&gt;.  Also when we benchmark
our own &lt;a href=&#34;https://github.com/rurban/safeclib/blob/master/tests/perf_memcpy_s.c&#34;&gt;memcpy_s&lt;/a&gt;
implementation against the assembler optimized memcpy from
libc. clang-5 can now easily vectorize and unrool the memcpy loop, and
my own &lt;code&gt;memcpy_s()&lt;/code&gt; in pure portable C is now as fast as the system
&lt;code&gt;memcpy()&lt;/code&gt;, even if my memcpy_s does perform all the necessary
overflow and vailidity checks. The trick is that most of that checks
are done at compile-time already. gcc is twice as slow.&lt;/p&gt;

&lt;h1 id=&#34;freebsd-glibc-hate-for-the-constraint-handler-crap&#34;&gt;FreeBSD/glibc hate for the constraint-handler &amp;ldquo;crap&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;One reason why the secure C11 Annex K API is not yet added to the various
libc&amp;rsquo;s is not ony because it was written and designed by Microsoft.
The public reason given is the mandatory constraint handler, which by
default does nothing in case of errors. But it can be set to a
user-defined handler, which logs those errors.&lt;/p&gt;

&lt;p&gt;With the new configure option &lt;code&gt;--disable-constraint-handler&lt;/code&gt; you can
now disable this feature and avoid this &amp;ldquo;crap&amp;rdquo;. But the performance
win is not measurable, only the binary size will go down. Because all
the static error strings will be left out of the &lt;code&gt;.cstrings&lt;/code&gt; section
in the binary. The performance is unchanged, because the handler is
only called in case of errors.&lt;/p&gt;

&lt;p&gt;But bsd/glibc are proud of their various MALLOC hooks, via run-time
getenv checks to help in bug hunting. The safeclib constraint handler
mechanism is much more performant than this, but you need to recompile
your software with a different constraint handler, or prepare such a
getenv check and install a handler at run-time.
There&amp;rsquo;s no technical reason not to use it as designed.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll certainly add lot of BOS checks to cperl also, esp. for XS
programmers. It was extremely useful when developing apps with
safeclib, and gcc is side-lined until they can come up with proper
retpoline names and constant-folding support to catch errors when
writing code, not in the test-suite or at the customer site.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>strict names</title>
      <link>http://perl11.org/blog/strict-names.html</link>
      <pubDate>Thu, 18 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/strict-names.html</guid>
      <description>

&lt;h1 id=&#34;consistent-identifier-parsing-rules&#34;&gt;Consistent identifier parsing rules&lt;/h1&gt;

&lt;p&gt;perl5 and cperl older than 5.27.0 accepts any string as valid
identifier name when being created under &lt;code&gt;no strict &#39;refs&#39;&lt;/code&gt; at
run-time, even when most such names are illegal, and cannot be handled
by most external modules.
Even invalid unicode is allowed.&lt;/p&gt;

&lt;p&gt;cperl 5.26 fixed embedded NUL&amp;rsquo;s and invalid unicode
identifiers &lt;a href=&#34;https://github.com/perl11/cperl/issues/233&#34;&gt;illegal&lt;/a&gt;,
and
&lt;a href=&#34;https://github.com/perl11/cperl/issues/228&#34;&gt;normalizes unicode identifiers&lt;/a&gt; in
the parser.&lt;/p&gt;

&lt;p&gt;Since cperl 5.27.1 dynamically created names are treated the same way
as when they are parsed. Which means illegal utf8 names are
rejected, unicode names are now normalized at run-time in the rv2sv
OP, via &lt;code&gt;${&amp;quot;string&amp;quot;}&lt;/code&gt; and mixed unicode scripts are also checked.&lt;/p&gt;

&lt;h1 id=&#34;strict-names&#34;&gt;strict names&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;strict &amp;lsquo;names&amp;rsquo;&lt;/strong&gt; is now implemented, included in the default and
enabled with cperl 5.27.1. It checks
for &lt;a href=&#34;http://perl11.org/cperl/perldata.html#Identifier-parsing&#34;&gt;valid identifiers&lt;/a&gt; being
created from strings under &lt;code&gt;no strict &#39;refs&#39;&lt;/code&gt; at run-time to match the
same rules as when they would have been created at compile-time by the
parser. Which helps
in &lt;a href=&#34;unicode-identifiers.html&#34;&gt;fighting invalid identifiers&lt;/a&gt;, which
cannot be handled by the rest of perl.
There was still room left to create invalid and
potentially harmful utf8 or binary names at run-time via &lt;code&gt;no strict &#39;refs&#39;&lt;/code&gt;.
strict names ensures no illegal name will get created.&lt;/p&gt;

&lt;p&gt;Note that p5p insists that illegal identifiers are still legal to
create at run-time. Only compile-time illegal identifiers are illegal.&lt;/p&gt;

&lt;p&gt;Currently it clashes with a reserved VMS hint. That means on VMS
strict names will be implemented in a slower way, via a hints hash
key, not a hints scalar bit.&lt;/p&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;This was legal before and is now illegal:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    use strict; no strict &#39;refs&#39;;

    ${&amp;quot;\xc3\x28&amp;quot;}
    
    my $s = &amp;quot;\xe2\x28\xa1&amp;quot;;
    ${$s}
    
    ${&amp;quot;$s\::xx&amp;quot;}
    
    ${&amp;quot;\cTAINT&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=&amp;gt; Invalid identifier &amp;ldquo;\24AINT&amp;rdquo; while &amp;ldquo;strict names&amp;rdquo; in use&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This symbol is since 5.26 normalized, previously not.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    use strict; no strict &amp;quot;refs&amp;quot;;
    my $café = &amp;quot;café&amp;quot;;   # &amp;lt;c, a, f, e, U+0301, U+0301&amp;gt;
    print $café;         # &amp;lt;c, a, f, U+00E9&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Empty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;café
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;And the illegal UTF-8 variant:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;     use strict; no strict &#39;refs&#39;;
     my $café = &amp;quot;café&amp;quot;; # &amp;lt;c, a, f, e, U+0301, U+0301&amp;gt; 
     print ${$café};    # &amp;lt;c, a, f, U+00E9&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Global symbol &amp;quot;$café&amp;quot; requires explicit package name (did you forget to declare &amp;quot;my $café&amp;quot;?) at -e line 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Malformed UTF-8 character: \x81 (unexpected continuation byte 0x81, with no preceding start byte) in scalar dereference at -e line 3.
Malformed UTF-8 character (fatal) at -e line 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cpan-impact&#34;&gt;CPAN Impact&lt;/h1&gt;

&lt;p&gt;Not many CPAN modules are affected by strict names being on by
default.  This is expected as strict names mostly protects against
run-time security attacks.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pod-Perldoc: &lt;a href=&#34;https://rt.cpan.org/Ticket/Display.html?id=121771&#34;&gt;https://rt.cpan.org/Ticket/Display.html?id=121771&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;my $version = do { no strict &#39;refs&#39;; ${ &#39;$&#39; . $class . &#39;::VERSION&#39; } };&lt;/code&gt;
=&amp;gt; Invalid identifier &amp;ldquo;$Pod::Perldoc::VERSION&amp;rdquo; while &amp;ldquo;strict names&amp;rdquo; in use&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cperl caught the wrong leading &lt;code&gt;$&lt;/code&gt; here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Scalar-List-Utils: tests for binary names without &lt;code&gt;no strict&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PathTools: File::Spec::Unix&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    my $taint = do { no strict; ${&amp;quot;\cTAINT&amp;quot;} };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default package &lt;code&gt;%main::&lt;/code&gt; is not detected yet with
&lt;code&gt;valid_ident()&lt;/code&gt;, so this fails under strict names, but would pass with
&lt;code&gt;${&amp;quot;::\cTAINT&amp;quot;}&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;EUMM: ExtUtils::MakeMaker::Locale&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Encode::Alias::define_alias(sub {
    no strict; # no strict names: &amp;quot;-&amp;quot; is an invalid IDCont
    no warnings &#39;once&#39;;
    return ${&amp;quot;ENCODING_&amp;quot; . uc(shift)};
}, &amp;quot;locale&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$ENCODING_UTF-8&lt;/code&gt; is an invalid identifier. So don&amp;rsquo;t use strict names.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-6bvokz-strict-names&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/6bvokz/strict_names/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Unicode Identifiers</title>
      <link>http://perl11.org/blog/unicode-identifiers.html</link>
      <pubDate>Tue, 07 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/unicode-identifiers.html</guid>
      <description>

&lt;h1 id=&#34;binary-names-with-5-16&#34;&gt;Binary names with 5.16&lt;/h1&gt;

&lt;p&gt;With perl 5.16 added support for binary names, announcing it as
support for unicode names. Unicode names were already supported since
5.8.4 with a negative length stored in the hash key of the symbol.&lt;/p&gt;

&lt;p&gt;Supporting binary names without any supporting measures opened huge
security holes, as names are mapped 1:1 to filenames when searching
for a package, and as we know the C API for files or names just
ignores a \0, leading to inconsistencies. And you could now easily
hide payloads in package names. Remember that p5p never announced this
problem and feature, they only announced it as improved and full
unicode support for names.  In the following years I had to fix most
of the problems with binary names support, but many critical modules
still have no idea, and are still vulnerable. Even the new perl5
maintainer has no idea as he showed in his YAPC talk about XS
programming. He happily used the old &lt;code&gt;gv_&lt;/code&gt; interfaces not supporting
\0, and there&amp;rsquo;s no upgrade path in perl5 for old modules to avoid those
security holes.&lt;/p&gt;

&lt;p&gt;Well, with unicode this would not have been a big problem, as our used
encoding UTF-8 does not support \0. It&amp;rsquo;s also illegal.
Only with cperl-5.26 we finally got back safe names, \0 is illegal again.&lt;/p&gt;

&lt;h1 id=&#34;unicode-security&#34;&gt;Unicode Security&lt;/h1&gt;

&lt;p&gt;But here we want to talk about the unicode problems when a language
decides to embrace unicode names. perl5 prides itself by being one of
the scripting languages with the best unicode support.  Well, the
libraries and strings, yes. But the language itself is still horribly
unicode unsafe.&lt;/p&gt;

&lt;p&gt;The unicode consortium published many security addendums, as TRnn.
Most of them are targetted to html forms, domains names used in
browsers or DNS servers, and email names. The problem with unicode is,
that different names are not identifiable as such, and thus you can
easily fool someone to click on a wrong url. Identifiers need to be
identifiable and restricted.  perl5 and perl6 pride themselves of
anything goes, it does not enforce opinions on their users. Well, it&amp;rsquo;s
still insecure.&lt;/p&gt;

&lt;p&gt;The simpliest unicode problems are tricks with illegal UTF-8
encodings.  This is also relevant to strings and therefore mostly
fixed in perl5 and cperl.&lt;/p&gt;

&lt;p&gt;But there are many more security problems in most programming
languages with unicode support. Only cperl, python3 and perl6 fixed
some of them, by doing normalization of its identifiers.
I didn&amp;rsquo;t see any effort in all the others, besides java.&lt;/p&gt;

&lt;p&gt;The most basic overview is at &lt;a href=&#34;http://websec.github.io/unicode-security-guide/&#34;&gt;http://websec.github.io/unicode-security-guide/&lt;/a&gt;.
Go read it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Because Unicode contains such a large number of characters and
 incorporates the varied writing systems of the world, incorrect usage
 can expose programs or systems to possible security attacks. This is
 especially important as more and more products are
 internationalized. This document describes some of the security
 considerations that programmers, system analysts, standards
 developers, and users should take into account, and provides specific
 recommendations to reduce the risk of problems.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The most important documents are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers&#34;&gt;TR31 Candidate Characters for Exclusion from Identifiers&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr36/&#34;&gt;TR36 Unicode Security Considerations&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr39/&#34;&gt;TR39 Unicode Security Mechanisms&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In short, those problems need to be fixed:&lt;/p&gt;

&lt;h1 id=&#34;mixed-scripts&#34;&gt;Mixed scripts&lt;/h1&gt;

&lt;p&gt;A written language is defined by its scripts (i.e. &amp;ldquo;alphabets&amp;rdquo;). Some
languages allow multiple scripts, such as modern Japanese uses both
logographic (kanji, originated from Chinese hanzi&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;) and syllabic
(kana) characters simultaneously, with two distinct types of kana
(hiragana and katakana).  So if you want to support japanese you need
allow all these three scripts to be used in a program, without any
declaration. Similar for Korean, which sometimes also use some old
Han/Chinese characters, and Chinese which uses the biggest set of
characters Han, plus one additional educational script, called
Bopomofo.&lt;/p&gt;

&lt;p&gt;The problem is very apparent with Cyrillic and Greek. Both are
different languages, but use almost the same characters, which are not
identifiable in any font. If the character is a Greek or Cyrillic
symbol, or if it&amp;rsquo;s one of the mathematical symbols.&lt;/p&gt;

&lt;p&gt;So strict mixed-script profiles for identifiers forbid the default
usage of Greek and Cyrillic characters in the same program.&lt;/p&gt;

&lt;p&gt;In cperl, which is currently the only unicode safe language, this
is forbidden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8;
my $Γ = 1;
if ($Г) { warn; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;use utf8&lt;/code&gt; declares that identifiers can be unicode, utf-8 encoded.
&lt;code&gt;my $Γ = 1&lt;/code&gt; sets a scalar lexical variable to 1, with the name &lt;code&gt;Γ&lt;/code&gt;.
What you don&amp;rsquo;t see, only the parser, or if you inspect the program
binary, e.g. with od, is that the first Γ character is the greek
gamma, and the second variable uses the cyrillic gamma.
Only with a restricted identifier profile you will see the problem.&lt;/p&gt;

&lt;p&gt;cperl does this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cperl5.26.0 -e&#39;use utf8;my $Γ = 1;if ($Г) { warn }&#39;
Invalid script Cyrillic in identifier Г) { warn }
for U+0413. Have Greek at -e line 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I.e. it allows the first greek character in a name to be used without
declaration of a foreign script, but then fails when a cyrillic
character in a name appears. With such characters in strings or
buffers the user has to care, but with identifiers the parser has to
care, as the identifier is not identifiable anymore.&lt;/p&gt;

&lt;p&gt;When a user really wants to use names in multiple languages in a
program, he needs to declare them beforehand, so the casual reader is
aware of the mixed scripts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8 (&amp;quot;Greek&amp;quot;, &amp;quot;Cyrillic&amp;quot;);
my $Γ = 1;
if ($Г) { warn }&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is now a somewhat valid variant. But note that mixing Cyrillic and
Greek is still frowned upon, and needs to be warned, even when being
declared as such.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=&amp;gt; Invalid script Cyrillic, cannot be mixed with Greek
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarily, some scripts can be used undeclared, and some need to be
declared.  These recommendations are all specified in the TR39
Restriction levels.&lt;/p&gt;

&lt;h1 id=&#34;visual-spoofing&#34;&gt;Visual spoofing&lt;/h1&gt;

&lt;p&gt;Unicode is pretty good in defining what characters are allowed as
first character in an identifier, and what characters may
follow. These classes are declared in the &lt;code&gt;ID_Start&lt;/code&gt; and
&lt;code&gt;ID_Continue&lt;/code&gt;, see
&lt;a href=&#34;http://www.unicode.org/reports/tr31/#Table_Lexical_Classes_for_Identifiers&#34;&gt;TR 31 Lexical_Classes_for_Identifiers&lt;/a&gt;
for the precise rules properly used in most languages with unicode
support.&lt;/p&gt;

&lt;p&gt;I know only of one bug in these tables, the U+3164 HANGUL FILLER is
wrongly specified as ID_Cont. Thus in perl5 this is valid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -e&#39;use utf8; $aㅤb == 2;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but cperl detects the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cperl -e&#39;use utf8; $aㅤb == 2;&#39;
Unrecognized character \x{3164}; marked by &amp;lt;-- HERE after e utf8; $a&amp;lt;-- HERE
near column 13 at -e line 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same problem for the U+ffa0 HALFWIDTH HANGUL FILLER. See also
&lt;a href=&#34;https://github.com/jagracey/Awesome-Unicode#user-content-variable-identifiers-can-effectively-include-whitespace&#34;&gt;https://github.com/jagracey/Awesome-Unicode#user-content-variable-identifiers-can-effectively-include-whitespace&lt;/a&gt;
According to according to
&lt;a href=&#34;http://www.unicode.org/L2/L2006/06310-hangul-decompose9.pdf&#34;&gt;http://www.unicode.org/L2/L2006/06310-hangul-decompose9.pdf&lt;/a&gt; those two
fillers ᅟ..ᅠ HANGUL CHOSEONG FILLER..HANGUL JUNGSEONG FILLER are the
proper replacements.&lt;/p&gt;

&lt;p&gt;But besides those rare bugs, spoofs and confusables are much more common.
I only know of very few languages which actually detect those problems.&lt;/p&gt;

&lt;p&gt;Spoofs are certain trick character combinations.&lt;/p&gt;

&lt;p&gt;Popular spoof attacks were the Paypal.com IDN spoof of 2005. Setup to
demonstrate the power of these attack vectors, Eric Johanson and The
Schmoo Group successfully used a www.paypal.com lookalike domain name
to fool visitors into providing personal information. The advisory
references original research from 2002 by Evgeniy Gabrilovich and Alex
Gontmakher at the Israel Institute of Technology. Their original paper
described an attack using Microsoft.com as an example. - &lt;a href=&#34;http://websec.github.io/unicode-security-guide/visual-spoofing/&#34;&gt;visual-spoofing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A typical bidi-spoof would involve a unicode aware text-editor or
viewer, and identifiers which switch to right-to-left (arabic),
overwrite the previous characters, and maybe even switch back to
left-to-right. Visually the names look the same, but internally the
spoofed name is much longer.&lt;/p&gt;

&lt;p&gt;Such spoofs are usually prevented with forbidding mixed scripts.&lt;/p&gt;

&lt;h1 id=&#34;normalization&#34;&gt;Normalization&lt;/h1&gt;

&lt;p&gt;Other simple spoofs can be be prevented with normalization. This is
what Python3 started to do, also cperl and java.  With normalization
of unicode character sequences all possible and valid character
combinations are compressed to one single normal form. There are two
defined normal forms, NFKC and NFC, interestingly python decided to
pick the wrong one, normalizing to ligatures. cperl normalizes to the
canonical normal form NFC. perl6 decided to normalize to their own
format, called NFD, which allows invalid, private reserved characters
in upper planes, which will be forbidden in upcoming perl5 and cperl
releases.&lt;/p&gt;

&lt;p&gt;E.g. &lt;code&gt;café&lt;/code&gt; (&lt;code&gt;&amp;lt;c, a, f, e, U+0301&amp;gt;&lt;/code&gt;) is normalized to &lt;code&gt;café&lt;/code&gt;
&lt;code&gt;&amp;lt;c, a, f, U+00E9&amp;gt;&lt;/code&gt;.
&lt;code&gt;café́&lt;/code&gt;, using two combining marks (&lt;code&gt;&amp;lt;c, a, f, e, U+0301, U+0301&amp;gt;&lt;/code&gt;) is currently allowed.&lt;/p&gt;

&lt;h1 id=&#34;same-script-confusables&#34;&gt;Same Script Confusables&lt;/h1&gt;

&lt;p&gt;There&amp;rsquo;s a whole table of confusables which are still confusable after
restricting mixed scripts and after normalization.
These confusables are typically optionally warned upon.&lt;/p&gt;

&lt;h1 id=&#34;moderately-restrictive-level&#34;&gt;Moderately Restrictive Level&lt;/h1&gt;

&lt;p&gt;cperl as first dynamic scripting language follows the &lt;strong&gt;General
Security Profile&lt;/strong&gt; for identifiers in programming languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Moderately Restrictive&lt;/strong&gt;: Allow &lt;code&gt;Latin&lt;/code&gt; with other Recommended or
Aspirational scripts except &lt;code&gt;Cyrillic&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt;. Otherwise, the same as
&lt;a href=&#34;http://www.unicode.org/reports/tr39/#Identifier_Characters&#34;&gt;Highly Restrictive&lt;/a&gt;,
i.e. allow &lt;code&gt;:Japanese&lt;/code&gt;, &lt;code&gt;:Korean&lt;/code&gt; and &lt;code&gt;:Hanb&lt;/code&gt; aliases.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Some characters are not in modern customary use, and thus implementations
may want to exclude them from identifiers.  These include characters in
historic and obsolete scripts, scripts used mostly liturgically, and
regional scripts used only in very small communities or with very limited
current usage.  The set of characters in Table 4, Candidate Characters for
Exclusion from Identifiers provides candidates of these.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;cperl honors the
&lt;a href=&#34;http://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers&#34;&gt;TR31 Candidate Characters for Exclusion from Identifiers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I.e. You may still declare those scripts as valid, but they are not
automatically allowed, similar to the need to declare mixed scripts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8;
my $ᭅ = 1; # \x{1b45} BALINESE LETTER KAF SASAK

=&amp;gt; Invalid script Balinese in identifier ᭅ for U+1B45
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but when declared as such:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8 &#39;Balinese&#39;;
my $ᭅ = 1; # \x{1b45} BALINESE LETTER KAF SASAK
print &amp;quot;ok&amp;quot;;

=&amp;gt; ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scripts listed at &amp;ldquo;Table 6, Aspirational Use Scripts&amp;rdquo;:
&lt;code&gt;Canadian_Aboriginal&lt;/code&gt;, &lt;code&gt;Miao&lt;/code&gt;, &lt;code&gt;Mongolian&lt;/code&gt;, &lt;code&gt;Tifinagh&lt;/code&gt; and &lt;code&gt;Yi&lt;/code&gt;
are included, i.e. need not to be declared.&lt;/p&gt;

&lt;p&gt;With this restriction we are close to the implementation of the
Moderately Restrictive level for identifiers by default. See
&lt;a href=&#34;http://www.unicode.org/reports/tr39/#General_Security_Profile&#34;&gt;http://www.unicode.org/reports/tr39/#General_Security_Profile&lt;/a&gt; and
&lt;a href=&#34;http://www.unicode.org/reports/tr36/#Security_Levels_and_Alerts&#34;&gt;http://www.unicode.org/reports/tr36/#Security_Levels_and_Alerts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With special declarations of the used scripts you can weaken the
restriction level to &lt;strong&gt;Minimally Restrictive&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Missing for the &lt;strong&gt;Moderately Restrictive&lt;/strong&gt; level are warnings on
single-, mixed and whole-script confusables, and warnings on certain
incompatible mixed-script pairs such as &lt;strong&gt;Greek + Cyrillic&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;All utf8 encoded names are checked for wellformed-ness.&lt;/p&gt;

&lt;h1 id=&#34;comments-at-r-cperl-https-www-reddit-com-r-cperl-comments-5y063u-unicode-identifiers&#34;&gt;&lt;a href=&#34;https://www.reddit.com/r/cperl/comments/5y063u/unicode_identifiers/&#34;&gt;Comments at /r/cperl/&lt;/a&gt;&lt;/h1&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;In Unicode, they&amp;rsquo;re generally unified into a single set, via a process called &amp;ldquo;Han unification&amp;rdquo;. So, unlike Greek &amp;ldquo;Α&amp;rdquo; vs Cyrillic &amp;ldquo;А&amp;rdquo;, the &amp;ldquo;same&amp;rdquo; character that may even look slightly differently in Chinese vs Japanese (e.g. &amp;ldquo;海&amp;rdquo;), would have a single codepoint in Unicode.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>The dangerous SipHash myth</title>
      <link>http://perl11.org/blog/seed.html</link>
      <pubDate>Sat, 26 Nov 2016 12:35:00 +0200</pubDate>
      
      <guid>http://perl11.org/blog/seed.html</guid>
      <description>&lt;p&gt;SipHash claims that its &amp;ldquo;cryptographically strong pseudo random
function&amp;rdquo; properties protects against hash table DoS flood attacks.
This is wrong, because for a successful attack against a SipHash hash
table with chained linked lists or linear probing it is enough to get
the secret random seed, and then brute force create collisions, which
is doable in &amp;lt;1s for 16k keys, 2m for 16k keys, and from 32k to 268M
keys in 4 minutes. For any hash function, SipHash, AES or even SHA256.
Which is far from being secure. Declaring a hash function for a hash
table secure is wrong and pure security theatre, which unfortunately
a lot of people started to believe in.&lt;/p&gt;

&lt;p&gt;Normally you can prepare collisions offline, but as you see you can
even create them online as soon as you know the seed.  Inserting 64k
keys needs 32 seconds vs 0.01 seconds on e.g. PHP, from constant to
quadratic, with an amplification factor of 200.
&lt;a href=&#34;https://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html&#34;&gt;https://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So the only protection is the secrecy of the random seed, which has
nothing to do with any properties of SipHash per se. A hash
function can never protect a hash table from hash flood attacks on
hash tables with simple lists on collisions. SipHash properties are
that is not reversible, the seed is mixed in the box and not only
at the beginning, so it&amp;rsquo;s is hard to get the seed from the hash
function itself. But there&amp;rsquo;s no need for it, as it is trivial to
get the seed via other means. The collisions are prone to timing
attacks independent on the hash function, usually the hash
iterator exposes the inner ordering and in most cases the random
seed is exposable via traditional memory exposure. If the seed is
hash table specific or global, i.e. process or thread specific.&lt;/p&gt;

&lt;p&gt;E.g. in debian perl you get the seed at process startup via&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ PERL_HASH_SEED_DEBUG=1 /usr/bin/perl -e0
=&amp;gt; HASH_FUNCTION = ONE_AT_A_TIME_HARD HASH_SEED = 0xd12d459fc36db4cf PERTURB_KEYS = 1 (RANDOM)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to stderr.&lt;/p&gt;

&lt;p&gt;On centos7:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ PERL_HASH_SEED_DEBUG=1 /usr/bin/perl -e0
=&amp;gt; HASH_SEED = 10452142639498245987
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Older centos 5 and 6 has an unpatched perl hash table function which
is vulnerable to much simplier DoS attacks, which is e.g. used on the
redhat openshift public cloud.&lt;/p&gt;

&lt;p&gt;For a running perl process the seed is at a known fixed offset.  Which
is easily readable via some kind of poke function via the unpack &amp;ldquo;P&amp;rdquo;
builtin op. See Devel::PeekPoke.  Similar for all other dynamic
languages exposing the value of any pointer. Which is esp. problematic
for languages who trusted the false claims of the SipHash authors,
that using this secure hash function it makes it safe against such DoS
attacks. Which are most prominently ruby, python, rust, haskell and
others.  Perl5 at least changed the order of the iterator, cperl
counts the collisions and adds a sleep on attacks, PHP limits the size
of external keys to be passed to the hash table so only JSON or other
formats are easily DoS-able. But more serious applications such as the
linux kernel, glibc, cache or DNS servers use better hash table
collisions schemes than unsafe chaining or linear probing.&lt;/p&gt;

&lt;p&gt;Vulnerable are all implementors of hash tables who believed the false
claims of the SipHash authors: ruby, python, rust, haskell, OpenBSD
and some more.  But also others who don&amp;rsquo;t use a proper hash table
collision resolution scheme or don&amp;rsquo;t protect their seed or easily
expose the seed, such as perl5 and many more.  rust currently
e.g. believes that SipHash makes it secure even if a trivial attack
was just found against it, and changing the seed at table resize will
help. It only helps a bit.  The seed is still exposable.  With an
amplification factor of 200 with a table size large enough there&amp;rsquo;s
enough attack surface to render a service useless.
Reseeding on resize will lead to an amplification factor of 6.&lt;/p&gt;

&lt;p&gt;Links:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/highwayhash/issues/28&#34;&gt;google/highwayshash False security claims&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rurban/smhasher/#security&#34;&gt;SMHasher on Security&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rurban/perl-hash-stats&#34;&gt;perl hash stats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>