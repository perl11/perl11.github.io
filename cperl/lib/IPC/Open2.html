<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@osx201.apple.com" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#WARNING">WARNING</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>IPC::Open2 - open a process for both reading and writing using open2()</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use IPC::Open2;

    $pid = open2(\*CHLD_OUT, \*CHLD_IN, &#39;some cmd and args&#39;);
      # or without using the shell
    $pid = open2(\*CHLD_OUT, \*CHLD_IN, &#39;some&#39;, &#39;cmd&#39;, &#39;and&#39;, &#39;args&#39;);

    # or with handle autovivification
    my($chld_out, $chld_in);
    $pid = open2($chld_out, $chld_in, &#39;some cmd and args&#39;);
      # or without using the shell
    $pid = open2($chld_out, $chld_in, &#39;some&#39;, &#39;cmd&#39;, &#39;and&#39;, &#39;args&#39;);

    waitpid( $pid, 0 );
    my $child_exit_status = $? &gt;&gt; 8;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It&#39;s what you think should work when you try</p>

<pre><code>    $pid = open(HANDLE, &quot;|cmd args|&quot;);</code></pre>

<p>The write filehandle will have autoflush turned on.</p>

<p>If $chld_out is a string (that is, a bareword filehandle rather than a glob or a reference) and it begins with <code>&gt;&amp;</code>, then the child will send output directly to that file handle. If $chld_in is a string that begins with <code>&lt;&amp;</code>, then $chld_in will be closed in the parent, and the child will read from it directly. In both cases, there will be a dup(2) instead of a pipe(2) made.</p>

<p>If either reader or writer is the null string, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</p>

<p>open2() returns the process ID of the child process. It doesn&#39;t return on failure: it just raises an exception matching <code>/^open2:/</code>. However, <code>exec</code> failures in the child are not detected. You&#39;ll have to trap SIGPIPE yourself.</p>

<p>open2() does not wait for and reap the child process after it exits. Except for short programs where it&#39;s acceptable to let the operating system take care of this, you need to do this yourself. This is normally as simple as calling <code>waitpid $pid, 0</code> when you&#39;re done with the process. Failing to do this can result in an accumulation of defunct or &quot;zombie&quot; processes. See <a href="/cperl/perlfunc.html#waitpid">&quot;waitpid&quot; in perlfunc</a> for more information.</p>

<p>This whole affair is quite dangerous, as you may block forever. It assumes it&#39;s going to talk to something like <b>bc</b>, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like <b>bc</b> will read a line at a time and output a line at a time. Programs like <b>sort</b> that read their entire input stream first, however, are quite apt to cause deadlock.</p>

<p>The big problem with this approach is that if you don&#39;t have control over source code being run in the child process, you can&#39;t control what it does with pipe buffering. Thus you can&#39;t just open a pipe to <code>cat -v</code> and continually read and write a line from it.</p>

<p>The IO::Pty and Expect modules from CPAN can help with this, as they provide a real tty (well, a pseudo-tty, actually), which gets you back to line buffering in the invoked command again.</p>

<h1 id="WARNING">WARNING</h1>

<p>The order of arguments differs from that of open3().</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>See <a href="/cperl/lib/IPC/Open3.html">IPC::Open3</a> for an alternative that handles STDERR as well. This function is really just a wrapper around open3().</p>


</body>

</html>


